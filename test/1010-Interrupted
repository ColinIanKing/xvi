#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

#
# Check that it says "Interrupted" when it should.
#

source term
start_vi

# Set the status line to anything other than "Interrupted"
proc clear_statusline { } {
    exp_send [ctrl G]	;# Prints the current filename etc
    term_expect timeout { fail 110 } \
	{ statusline_isnt "Interrupted" }
}

# Interrupt tests can take a little longer to happen
set timeout 4

# Tests begin

# Check it started up OK
term_expect timeout { fail 100 } \
	{ screen_is 1 0 [list "" "~"] }


# Interrupt it in keystroke command mode
#
# xvi and nvi say "Interrupted"; vim has its own message.

set vim FALSE	; # Are we running the tests using vim?

exp_send [ctrl C]
term_expect timeout { fail 101 } \
    { expr { [screen_is 1 0 [list "" "~"]] && \
	[statusline_is "Interrupted"] } } { } \
    { expr { [screen_is 1 0 [list "" "~"]] && \
	[statusline_starts "Type  :quit<Enter>  to exit Vim"] } } {
	set vim TRUE
    }


# Interrupt it after one char of a 2-char command
#
# vim doen't display anything when this happens but POSIX says:
# "SIGINT: If in open or visual command mode, the terminal shall be alerted."

clear_statusline
exp_send "z[ctrl C]"
term_expect timeout { fail 102 } \
    { expr { [screen_is 1 0 [list "" "~"]] &&
	     ( $vim || [statusline_is "Interrupted"] ) } }


# Interrupt it in insert mode

clear_statusline
exp_send "ii"
term_expect timeout { fail 103 } \
    { screen_is 1 1 "i" }
exp_send [ctrl C]
term_expect timeout { fail 104 } \
    { expr { [screen_is 1 0 [list "i" "~"]] &&
	     ( $vim || [statusline_is "Interrupted"] ) } }
# Check that you can quote it with ^V
clear_statusline
test 105 a[ctrl V]	1 1 "i^"
exp_send [ctrl C]
term_expect timeout { fail 106 } \
    { expr { [screen_is 1 3 [list "i^C" "~"]] &&
	     ( $vim || [statusline_isnt "Interrupted"] ) } }
exp_send [esc]


# Interrupt it in replace mode

clear_statusline
exp_send "0Daabc[esc]h"
term_expect timeout { fail 107 } \
    { screen_is 1 1 "abc" }
exp_send "RX"
term_expect timeout { fail 108 } \
    { screen_is 1 2 "aXc" }
exp_send [ctrl C]
term_expect timeout { fail 109 } \
    { expr { [screen_is 1 1 "aXc"] &&
	     ( $vim || [statusline_is "Interrupted"] ) } }
# Check that you can quote it with ^V
clear_statusline
test 110 "0Cabc[esc]hr[ctrl V]"	1 1 "a^c"
if { ! ( $vim || [statusline_isnt "Interrupted"] ) } { fail 111 }
test 112 [ctrl C]		1 1 "a^Cc"
if { ! ( $vim || [statusline_isnt "Interrupted"] ) } { fail 113 }
test 114 "0Cabc[esc]hR[ctrl V]"	1 1 "a^c"
test 115 "[ctrl C]"		1 3 "a^Cc"
if { ! ( $vim || [statusline_isnt "Interrupted"] ) } { fail 116 }
exp_send [esc]


# Interrupt it in command line mode

clear_statusline
exp_send "0D:"
term_expect timeout { fail 117 } \
    { expr { [statusline_is ":"] && [screen_is $rows 1 [list "" "~"]] } }
exp_send [ctrl C]
term_expect timeout { fail 118 } \
    { expr { [screen_is 1 0 [list "" "~"]] &&
	     ( $vim || [statusline_is "Interrupted"] ) } }
# Check that you can quote it with ^V
clear_statusline
ctest 119 ":a[ctrl V]"	2 ":a^"
ctest 120 [ctrl C]	4 ":a^C"
if { ! ( $vim || [statusline_isnt "Interrupted"] ) } { fail 121 }


# Interrupt it while doing infinite macro recursion

exp_send ":map x y\r"
exp_send ":map y x\r"
exp_send "x"
exp_send [ctrl C]
term_expect timeout { fail 122 } \
    { expr { [screen_is 1 0 [list "" "~"]] &&
	     ( $vim || [statusline_is "Interrupted"] ) } }

exp_send ":map! x axy\r"
exp_send "ax"
# The x should send it into a loop, appending content madly.
# POSIX says "If there is a currently executing command, it shall be aborted
# and a message displayed".
# and nvi shows "Interrupted: mapped keys discarded".

# Give it time to fill the screen with a's
sleep 1

# Interrupt it
exp_send [ctrl C]
term_expect timeout { fail 123 } \
    { expr { $vim || [statusline_starts "Interrupted"] } }

# Now it should react to ":"
exp_send ":"
term_expect timeout { fail 124 } \
    { expr { [statusline_is ":"] && [cursor_at $rows 1] } }

exp_send "q!\r"

exit 0
