/* Copyright (c) 1990,1991,1992,1993 Chris and John Downey */
#ifndef lint
static char *sccsid = "@(#)update.c	1.3 (Chris & John Downey) 12/10/93";
#endif

/***

* program name:
    xvi
* function:
    Portable version of UNIX "vi" editor, with extensions.
* module name:
    update.c
* module function:
    Update what is on the screen, according to what is in the
    internal and external screen buffers (presumably the internal
    one has been changed).
* history:
    STEVIE - ST Editor for VI Enthusiasts, Version 3.10
    Originally by Tim Thompson (twitch!tjt)
    Extensive modifications by Tony Andrews (onecom!wldrdg!tony)
    Heavily modified by Chris & John Downey

***/

#include "xvi.h"

static	void	xvUpdateLine P((Xviwin *, VirtScr *, int));
static	void	xvWriteMultiString
		    P((VirtScr *, char *, int, unsigned char *, int, int));
static	void	xvWriteColouredString
		    P((VirtScr *, char *, int, unsigned, int, int));

/*
 * Transfer the contents of int_lines to the screen,
 * starting at "start_row", for "nlines" lines,
 * using ext_lines to avoid unnecessary output.
 */
void
xvUpdateScr(win, vs, start_row, nlines)
Xviwin			*win;
register VirtScr	*vs;
int			start_row;
int			nlines;
{
    register int	row;		/* current row */
    int         	end_row;	/* row after last one to be updated */

    if (!(echo & e_CHARUPDATE)) {
	return;
    }

    end_row = start_row + nlines;

    VSset_colour(vs, VSCcolour);

    for (row = start_row; row < end_row; row++) {
	register unsigned	nflags;
	register unsigned	rflags;		/* flags for current lines */

	nflags = vs->pv_int_lines[row].s_flags;
	rflags = vs->pv_ext_lines[row].s_flags;

	/*
	 * Only update the line if necessary.
	 */
	if ((nflags & S_DIRTY) || (rflags & S_DIRTY)) {
	    xvUpdateLine(win, vs, row);

	    /*
	     * The real screen line is a message or command line if the
	     * newly-updated one was. Otherwise, it isn't.
	     *
	     * Both the new and real screens may now be considered "clean".
	     */
	    vs->pv_ext_lines[row].s_flags = (
		/*
		 * Turn these flags off first ...
		 */
		(rflags & ~(S_STATUS | S_DIRTY))
		/*
		 * ... then set whatever S_STATUS flags are
		 * set in int_lines.
		 */
		| (nflags & S_STATUS)
	    );
	    vs->pv_int_lines[row].s_flags &= ~S_DIRTY;
	}
    }
    VSflush(vs);
}

#if 0
/*
 * Update the given line to the screen. This routine is only called
 * if either the internal image, or the screen itself, has changed
 * (i.e. is marked "dirty").
 */
static void
xvUpdateLine(win, vs, row)
Xviwin		*win;
VirtScr		*vs;
int		row;
{
    Sline		*new;		/* pointers to current lines */
    Sline		*real;
    register unsigned	nflags;		/* flags for current lines */
    unsigned		rflags;
    register char	*ntextp;	/* pointers to line text */
    register char	*rtextp;
    unsigned char	*ncolours;	/* pointers to character colours */
    unsigned char	*rcolours;
    int			n_used;
    int			r_used;
    int			columns;

    columns = VScols(vs);

    nflags = (new = vs->pv_int_lines + row)->s_flags;
    rflags = (real = vs->pv_ext_lines + row)->s_flags;

    ntextp = new->s_line;
    rtextp = real->s_line;
    ncolours = new->s_colour;
    rcolours = real->s_colour;

    n_used = new->s_used;
    r_used = real->s_used;

    /*
     * If the line is a command line, but colour_cost is not zero, we
     * do not bother with setting the prompt character to a different
     * colour, as it complicates the algorithm too much. So just pretend
     * that the line is an ordinary one.
     */
    if ((nflags & S_COMMAND) && win->w_colour_cost != 0) {
	nflags &= ~S_STATUS;
    }

    /*
     * There are three possible "types" of line: text, command and message.
     *
     * We always update message lines completely to avoid problems with
     * moving the cursor while in a different colour.
     *
     * Text and command lines are subject to update optimisation. Command
     * lines have the first character the same colour as the message line
     * would be, but after that are treated in the same way as text lines.
     *
     * If the type of a line changes, and the new type is not "message",
     * we have to be careful: so in this case we first clear the whole
     * line to avoid problems. This simplifies updating quite a lot.
     */

    if (nflags & S_MESSAGE) {
	/*
	 * Message lines always get completely updated.
	 */
	VSset_colour(vs, (nflags & S_READONLY) ? VSCroscolour :
					    VSCstatuscolour);
	VSwrite(vs, row, 0, ntextp);
	if (n_used < columns) {
	    VSclear_line(vs, row, n_used);
	}
	VSset_colour(vs, VSCcolour);

	(void) strncpy(rtextp, ntextp, (int) (columns - win->w_spare_cols));
    } else {
	register int	col;		/* current column */
	register int	adv_col;	/* column after last to be updated */

	if ((rflags & S_STATUS) != (nflags & S_STATUS)) {
	    /*
	     * This line's type has changed. Clear the whole line
	     * first, and then update the data structures to show
	     * it as blank so that the normal update will work.
	     */
	    VSclear_line(vs, row, 0);
	    r_used = 0;
	    rtextp[0] = '\0';
	    rflags &= ~S_STATUS;
	}

	/*
	 * A command line should have the first character
	 * - and only the first character - highlighted.
	 */
	if (nflags & S_COMMAND) {
	    if (ntextp[0] != rtextp[0]) {
		VSset_colour(vs, (nflags & S_READONLY) ?
				VSCroscolour : VSCstatuscolour);
		VSputc(vs, row, 0, ntextp[0]);
		rtextp[0] = ntextp[0];
		VSset_colour(vs, VSCcolour);
	    }
	    col = adv_col = 1;
	} else {
	    col = adv_col = 0;
	}

	/*
	 * Look at each character in the line, comparing the new version
	 * with the one on the screen. If they differ, put it out.
	 *
	 * adv_col is the column following the last one to be updated;
	 * we use it for VSadvise().
	 *
	 * Note that this loop needs to be as tight as possible,
	 * since it is the core of screen updating.
	 */
	for (; col < n_used && col < r_used; col++) {
	    register int	nc;

	    nc = ntextp[col];
	    if (nc != rtextp[col] || ncolours[col] != rcolours[col]) {
		/*
		 * They are different. Get to the right
		 * place before putting out the char.
		 */
		/*
		 * PROBLEM: how do we handle VSadvise() and colours?
		 * - the advisory text could contain a mix of colours.
		 */
		if (col > adv_col) {
		    VSadvise(vs, row, adv_col, col - adv_col,
			     ntextp + adv_col);
		}

		VSset_colour(vs, ncolours[col]);
		VSputc(vs, row, col, nc);

		adv_col = col + 1;
		rtextp[col] = nc;
		rcolours[col] = ncolours[col];
	    }
	}

	if (n_used > r_used) {
	    /*
	     * We have got to the end of the previous
	     * screen line; if there is anything left,
	     * we should just display it.
	     */
	    (void) strcpy(&rtextp[col], &ntextp[col]);
	    /*
	     * Skip over initial whitespace.
	     */
	    while (ntextp[col] == ' ') {
		col++;
	    }
	    if (col < columns) {
		if (col > 0 && !(nflags & S_STATUS) && col > adv_col) {
		    VSadvise(vs, row, adv_col, col - adv_col,
			     ntextp + adv_col);
		}
		/*
		 * PROBLEM: can't do this now. We should write a new
		 * routine which puts out a line containing different
		 * colours. This could also be used for message lines.
		 */
		VSwrite(vs, row, col, &ntextp[col]);
	    }
	} else if (r_used > n_used) {
	    /*
	     * We have got to the end of the new screen
	     * line, but the old one still has stuff on
	     * it. We must therefore clear it.
	     */
	    VSclear_line(vs, row, col);
	}
    }

    real->s_line[n_used] = '\0';
    real->s_used = n_used;
}
#endif /* 0 */

/*
 * NEW VERSION
 */
static void
xvUpdateLine(win, vs, row)
Xviwin		*win;
VirtScr		*vs;
int		row;
{
    Sline		*new;		/* pointers to current lines */
    Sline		*real;
    register char	*ntextp;	/* pointers to line text */
    register char	*rtextp;
    unsigned char	*ncolours;	/* pointers to character colours */
    unsigned char	*rcolours;
    int			n_used;
    int			r_used;
    int			columns;
    bool_t		ncoloured;	/* TRUE if ntextp has colour */
    int			i;

    columns = VScols(vs);

    ntextp = new->s_line;
    rtextp = real->s_line;
    ncolours = new->s_colour;
    rcolours = real->s_colour;

    n_used = new->s_used;
    r_used = real->s_used;

    ncoloured = FALSE;
    for (i = 0; i < n_used; i++) {
	if (ntextp[i] != VSCcolour) {
	    ncoloured = TRUE;
	    break;
	}
    }

    if (ncoloured) {
	/*
	 * Coloured lines always get completely updated.
	 */
	xvWriteMultiString(vs, ntextp, n_used, ncolours, row, 0);
	if (n_used < columns) {
	    VSclear_line(vs, row, n_used);
	}

    } else {
	register int	col;		/* current column */
	register int	adv_col;	/* column after last to be updated */
	bool_t		do_advise;	/* TRUE if VSadvise() is advisory */
	unsigned	last_colour;	/* colour of last char written out */

	/*
	 * Look at each character in the line, comparing the new version
	 * with the one on the screen. If they differ, put the char out.
	 *
	 * adv_col is the column following the last one to be updated;
	 * we use it for VSadvise().
	 *
	 * Note that this loop needs to be as tight as possible,
	 * since it is the core of screen updating.
	 */
	do_advise = TRUE;
	last_colour = VSCcolour;
	for (col = adv_col = 0; col < n_used && col < r_used; col++) {
	    register int	nc;

	    nc = ntextp[col];
	    if (nc != rtextp[col] || ncolours[col] != rcolours[col]) {
		/*
		 * They are different. Get to the right
		 * place before putting out the char.
		 */
		if (col > adv_col && do_advise) {
		    VSadvise(vs, row, adv_col, col - adv_col,
			     ntextp + adv_col);
		}

		VSset_colour(vs, ncolours[col]);
		VSputc(vs, row, col, nc);

		adv_col = col + 1;
		do_advise = TRUE;
		last_colour = ncolours[col];
	    } else if (ncolours[col] != last_colour) {
		/*
		 * If the colour has changed since adv_col, we cannot
		 * perform a VSadvise(), so reset do_advise here to
		 * prevent it from happening.
		 */
		do_advise = FALSE;
	    }
	}

	if (n_used > r_used) {
	    /*
	     * We have got to the end of the previous
	     * screen line; if there is anything left,
	     * we should just display it.
	     */

	    /*
	     * Skip over initial (background-coloured) whitespace.
	     */
	    while (ntextp[col] == ' ' && ncolours[col] == VSCcolour) {
		col++;
	    }
	    if (col < columns) {
		if (do_advise && col > 0 && !(nflags & S_STATUS) &&
							col > adv_col) {
		    VSadvise(vs, row, adv_col, col - adv_col,
			     ntextp + adv_col);
		}
		xvWriteMultiString(vs, &ntextp[col], n_used - col,
					&ncolours[col], row, col);
	    }
	} else if (r_used > n_used) {
	    /*
	     * We have got to the end of the new screen
	     * line, but the old one still has stuff on
	     * it. We must therefore clear it.
	     */
	    VSclear_line(vs, row, col);
	}
    }

    (void) memcpy(real->s_line, new->s_line, n_used);
    (void) memcpy(real->s_colour, ,new->s_colour n_used);
    real->s_line[n_used] = '\0';
    real->s_used = n_used;
}

/*
 * Write a string containing multiple coloured sections at the given
 * location. The colours are given by the byte array "colours".
 */
static void
xvWriteMultiString(vs, str, length, colours, row, col)
VirtScr		*vs;
char		*str;
int		length;
unsigned char	*colours;
int		row, col;
{
    int		i;

    for (i = 0; i < length; i++) {
	VSset_colour(vs, colours[i]);
	VSputc(vs, row, col++, str[i]);
    }
}

/*
 * Write a string of a single specified colour at the given location.
 */
static void
xvWriteColouredString(vs, str, length, colour, row, col)
VirtScr		*vs;
char		*str;
int		length;
unsigned	colour;
int		row, col;
{
    int		i;

    VSset_colour(vs, colour);
    for (i = 0; i < length; i++) {
	VSputc(vs, row, col++, str[i]);
    }
}

/*
 * Set the S_DIRTY bit for a given line in both ext_lines &
 * int_lines if the stored representations are in fact different:
 * otherwise clear it. The line is an index into the VirtScr.
 */
void
xvMarkDirty(vs, row)
VirtScr	*vs;
int	row;
{
    Sline	*rp;
    Sline	*np;
    int		used;

    rp = vs->pv_ext_lines + row;
    np = vs->pv_int_lines + row;
    if (

	(rp->s_flags & ~S_DIRTY) != (np->s_flags & ~S_DIRTY)
	||
	(used = rp->s_used) != np->s_used
	||
	strncmp(rp->s_line, np->s_line, used) != 0
	||
	memcmp(rp->s_colour, np->s_colour, used) != 0
    ) {
	/*
	 * The lines are different.
	 */
	np->s_flags |= S_DIRTY;
	rp->s_flags |= S_DIRTY;
    } else {
	rp->s_flags = (np->s_flags &= ~S_DIRTY);
    }
}

/*
 * Clear the given line, marking it as dirty.
 * The line is a VirtScr index.
 */
void
xvClearLine(vs, line)
VirtScr		*vs;
unsigned	line;
{
    vs->pv_ext_lines[line].s_used = 0;
    vs->pv_ext_lines[line].s_line[0] = '\0';
    xvMarkDirty(vs, (int) line);
}

void
xvClear(vs)
VirtScr	*vs;
{
    register unsigned	row;
    register unsigned	nrows;

    nrows = VSrows(vs);

    VSset_colour(vs, VSCcolour);
    VSclear_all(vs);

    /*
     * Clear the real screen lines, and mark them as modified.
     */
    for (row = 0; row < nrows; row++) {
	xvClearLine(vs, row);
    }
}
